<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-03-13">

<title>IS415: Geospatial Analytics &amp; Applications - In-class Exercise 9: Geographical Segmentation with Spatially Constrained Clustering Techniques</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">IS415: Geospatial Analytics &amp; Applications</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-hands-on-exercise" role="button" data-bs-toggle="dropdown" aria-expanded="false">Hands-on Exercise</a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-hands-on-exercise">    
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html">
 <span class="dropdown-text">Hands-on Exercise 1: Geospatial Data Wrangling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html">
 <span class="dropdown-text">Hands-on Exercise 2: Choropleth Mapping</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03.html">
 <span class="dropdown-text">Hands-on Exercise 3: 1st Order Spatial Point Patterns</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html">
 <span class="dropdown-text">Hands-on Exercise 6: Spatial Weights</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex07_GLSA/Hands-on_Ex07_GLSA.html">
 <span class="dropdown-text">Hands-on Exercise 7: GLSA</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex07_EHSA/Hands-on_Ex07_EHSA.html">
 <span class="dropdown-text">Hands-on Exercise 7: EHSA</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08.html">
 <span class="dropdown-text">Hands-on Exercise 8: Hedonic Pricing Model (GWR)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09.html">
 <span class="dropdown-text">Hands-on Exercise 9: Geographical Segmentation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex10/Hands-on_Ex10.html">
 <span class="dropdown-text">Hands-on Exercise 10: Spatial Interaction Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Hands-on_Ex/Hands-on_Ex11/Hands-on_Ex11.html">
 <span class="dropdown-text">Hands-on Exercise 11: Geographical Accessibility</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-in-class-exercise" role="button" data-bs-toggle="dropdown" aria-expanded="false">In-class Exercise</a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-in-class-exercise">    
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex02/In-class_Ex02.html">
 <span class="dropdown-text">In-class Exercise 2: Geospatial Data Wrangling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex03/In-class_Ex03.html">
 <span class="dropdown-text">In-class Exercise 3: Choropleth Mapping</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex04/In-class_Ex04.html">
 <span class="dropdown-text">In-class Exercise 4: 2nd Order Spatial Point Patterns</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex05/In-class_Ex05.html">
 <span class="dropdown-text">In-class Exercise 5: Local Colocation Quotient</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex06/In-class_Ex06.html">
 <span class="dropdown-text">In-class Exercise 6: Spatial Weights (sfdep)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex07/In-class_Ex07.html">
 <span class="dropdown-text">In-class Exercise 7: EHSA (sfdep)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex08/In-class_Ex08.html">
 <span class="dropdown-text">In-class Exercise 8: Hedonic Pricing Model (GWR)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex09/In-class_Ex09.html">
 <span class="dropdown-text">In-class Exercise 9: Geographical Segmentation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex10/In-class_Ex10.html">
 <span class="dropdown-text">In-class Exercise 10: Spatial Interaction Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../In-class_Ex/In-class_Ex11/In-class_Ex11.html">
 <span class="dropdown-text">In-class Exercise 11: Geographical Accessibility</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-take-home-exercise" role="button" data-bs-toggle="dropdown" aria-expanded="false">Take-home Exercise</a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-take-home-exercise">    
        <li>
    <a class="dropdown-item" href="../../Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html">
 <span class="dropdown-text">Take-home Exercise 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html">
 <span class="dropdown-text">Take-home Exercise 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html">
 <span class="dropdown-text">Take-home Exercise 3</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#getting-started" id="toc-getting-started" class="nav-link active" data-scroll-target="#getting-started"><span class="toc-section-number">1</span>  Getting Started</a></li>
  <li><a href="#prepaing-the-data" id="toc-prepaing-the-data" class="nav-link" data-scroll-target="#prepaing-the-data"><span class="toc-section-number">2</span>  Prepaing the Data</a></li>
  <li><a href="#computing-correlation-matrix" id="toc-computing-correlation-matrix" class="nav-link" data-scroll-target="#computing-correlation-matrix"><span class="toc-section-number">3</span>  Computing Correlation Matrix</a></li>
  <li><a href="#retrieving-stored-data" id="toc-retrieving-stored-data" class="nav-link" data-scroll-target="#retrieving-stored-data"><span class="toc-section-number">4</span>  Retrieving Stored Data</a></li>
  <li><a href="#preparing-coordinates-data" id="toc-preparing-coordinates-data" class="nav-link" data-scroll-target="#preparing-coordinates-data"><span class="toc-section-number">5</span>  Preparing Coordinates Data</a></li>
  <li><a href="#dropping-geometry-columns" id="toc-dropping-geometry-columns" class="nav-link" data-scroll-target="#dropping-geometry-columns"><span class="toc-section-number">6</span>  Dropping Geometry Columns</a></li>
  <li><a href="#calibrating-random-forest" id="toc-calibrating-random-forest" class="nav-link" data-scroll-target="#calibrating-random-forest"><span class="toc-section-number">7</span>  Calibrating Random Forest</a></li>
  <li><a href="#calibrating-random-forest---adaptive" id="toc-calibrating-random-forest---adaptive" class="nav-link" data-scroll-target="#calibrating-random-forest---adaptive"><span class="toc-section-number">8</span>  Calibrating random forest - adaptive</a></li>
  <li><a href="#predicting-using-test-data" id="toc-predicting-using-test-data" class="nav-link" data-scroll-target="#predicting-using-test-data"><span class="toc-section-number">9</span>  Predicting using Test Data</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">In-class Exercise 9: Geographical Segmentation with Spatially Constrained Clustering Techniques</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 13, 2023</p>
    </div>
  </div>
    
  </div>
  

</header>

<section id="getting-started" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Getting Started</h1>
<p>ggpubr - stitch maps together, displaying outputs olsrr - introduced in hands on 8/ in class 8 for checking multicolinearity etc</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>pacman<span class="sc">::</span><span class="fu">p_load</span>(sf, GWmodel, SpatialML, tidyverse, tmap, ggpubr, olsrr, devtools, tidymodels)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="prepaing-the-data" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Prepaing the Data</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>mdata <span class="ot">&lt;-</span> <span class="fu">read_rds</span>(<span class="st">"data/aspatial/mdata.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><taken from="" hdb="" resale="" dataset=""></taken></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>resale_split <span class="ot">&lt;-</span> <span class="fu">initial_split</span>(mdata, </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">prop =</span> <span class="fl">6.5</span><span class="sc">/</span><span class="dv">10</span>,)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>train_data <span class="ot">&lt;-</span> <span class="fu">training</span>(resale_split)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>test_data <span class="ot">&lt;-</span> <span class="fu">testing</span>(resale_split)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">write_rds</span>(train_data, <span class="st">"data/model/train_data.rds"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">write_rds</span>(test_data, <span class="st">"data/model/test_data.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="computing-correlation-matrix" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Computing Correlation Matrix</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>mdata_nogeo <span class="ot">&lt;-</span> mdata <span class="sc">%&gt;%</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_drop_geometry</span>()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>corrplot<span class="sc">::</span>corrplot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (corr, method = c("circle", "square", "ellipse", "number", 
    "shade", "color", "pie"), type = c("full", "lower", "upper"), 
    col = NULL, col.lim = NULL, bg = "white", title = "", is.corr = TRUE, 
    add = FALSE, diag = TRUE, outline = FALSE, mar = c(0, 0, 
        0, 0), addgrid.col = NULL, addCoef.col = NULL, addCoefasPercent = FALSE, 
    order = c("original", "AOE", "FPC", "hclust", "alphabet"), 
    hclust.method = c("complete", "ward", "ward.D", "ward.D2", 
        "single", "average", "mcquitty", "median", "centroid"), 
    addrect = NULL, rect.col = "black", rect.lwd = 2, tl.pos = NULL, 
    tl.cex = 1, tl.col = "red", tl.offset = 0.4, tl.srt = 90, 
    cl.pos = NULL, cl.length = NULL, cl.cex = 0.8, cl.ratio = 0.15, 
    cl.align.text = "c", cl.offset = 0.5, number.cex = 1, number.font = 2, 
    number.digits = NULL, addshade = c("negative", "positive", 
        "all"), shade.lwd = 1, shade.col = "white", p.mat = NULL, 
    sig.level = 0.05, insig = c("pch", "p-value", "blank", "n", 
        "label_sig"), pch = 4, pch.col = "black", pch.cex = 3, 
    plotCI = c("n", "square", "circle", "rect"), lowCI.mat = NULL, 
    uppCI.mat = NULL, na.label = "?", na.label.col = "black", 
    win.asp = 1, ...) 
{
    method = match.arg(method)
    type = match.arg(type)
    order = match.arg(order)
    hclust.method = match.arg(hclust.method)
    addshade = match.arg(addshade)
    insig = match.arg(insig)
    plotCI = match.arg(plotCI)
    if (win.asp != 1 &amp;&amp; !(method %in% c("circle", "square"))) {
        stop("Parameter 'win.asp' is supported only for circle and square methods.")
    }
    asp_rescale_factor = min(1, win.asp)/max(1, win.asp)
    stopifnot(asp_rescale_factor &gt;= 0 &amp;&amp; asp_rescale_factor &lt;= 
        1)
    if (!is.matrix(corr) &amp;&amp; !is.data.frame(corr)) {
        stop("Need a matrix or data frame!")
    }
    if (is.null(addgrid.col)) {
        addgrid.col = switch(method, color = NA, shade = NA, 
            "grey")
    }
    if (any(corr[!is.na(corr)] &lt; col.lim[1]) || any(corr[!is.na(corr)] &gt; 
        col.lim[2])) {
        stop("color limits should cover matrix")
    }
    if (is.null(col.lim)) {
        if (is.corr) {
            col.lim = c(-1, 1)
        }
        else {
            if (!diag) {
                diag(corr) = NA
            }
            col.lim = c(min(corr, na.rm = TRUE), max(corr, na.rm = TRUE))
        }
    }
    SpecialCorr = 0
    if (is.corr) {
        if (min(corr, na.rm = TRUE) &lt; -1 - .Machine$double.eps^0.75 || 
            max(corr, na.rm = TRUE) &gt; 1 + .Machine$double.eps^0.75) {
            stop("The matrix is not in [-1, 1]!")
        }
        SpecialCorr = 1
        if (col.lim[1] &lt; -1 | col.lim[2] &gt; 1) {
            stop("col.lim should be within the interval [-1, 1]")
        }
    }
    intercept = 0
    zoom = 1
    if (!is.corr) {
        c_max = max(corr, na.rm = TRUE)
        c_min = min(corr, na.rm = TRUE)
        if ((col.lim[1] &gt; c_min) | (col.lim[2] &lt; c_max)) {
            stop("Wrong color: matrix should be in col.lim interval!")
        }
        if (diff(col.lim)/(c_max - c_min) &gt; 2) {
            warning("col.lim interval too wide, please set a suitable value")
        }
        if (c_max &lt;= 0 | c_min &gt;= 0) {
            intercept = -col.lim[1]
            zoom = 1/(diff(col.lim))
            if (col.lim[1] * col.lim[2] &lt; 0) {
                warning("col.lim interval not suitable to the matrix")
            }
        }
        else {
            stopifnot(c_max * c_min &lt; 0)
            stopifnot(c_min &lt; 0 &amp;&amp; c_max &gt; 0)
            intercept = 0
            zoom = 1/max(abs(col.lim))
            SpecialCorr = 1
        }
        corr = (intercept + corr) * zoom
    }
    col.lim2 = (intercept + col.lim) * zoom
    int = intercept * zoom
    if (is.null(col) &amp; is.corr) {
        col = COL2("RdBu", 200)
    }
    if (is.null(col) &amp; !is.corr) {
        if (col.lim[1] * col.lim[2] &lt; 0) {
            col = COL2("RdBu", 200)
        }
        else {
            col = COL1("YlOrBr", 200)
        }
    }
    n = nrow(corr)
    m = ncol(corr)
    min.nm = min(n, m)
    ord = 1:min.nm
    if (order != "original") {
        ord = corrMatOrder(corr, order = order, hclust.method = hclust.method)
        corr = corr[ord, ord]
    }
    if (is.null(rownames(corr))) {
        rownames(corr) = 1:n
    }
    if (is.null(colnames(corr))) {
        colnames(corr) = 1:m
    }
    apply_mat_filter = function(mat) {
        x = matrix(1:n * m, nrow = n, ncol = m)
        switch(type, upper = mat[row(x) &gt; col(x)] &lt;- Inf, lower = mat[row(x) &lt; 
            col(x)] &lt;- Inf)
        if (!diag) {
            diag(mat) = Inf
        }
        return(mat)
    }
    getPos.Dat = function(mat) {
        tmp = apply_mat_filter(mat)
        Dat = tmp[is.finite(tmp)]
        ind = which(is.finite(tmp), arr.ind = TRUE)
        Pos = ind
        Pos[, 1] = ind[, 2]
        Pos[, 2] = -ind[, 1] + 1 + n
        PosName = ind
        PosName[, 1] = colnames(mat)[ind[, 2]]
        PosName[, 2] = rownames(mat)[ind[, 1]]
        return(list(Pos, Dat, PosName))
    }
    getPos.NAs = function(mat) {
        tmp = apply_mat_filter(mat)
        ind = which(is.na(tmp), arr.ind = TRUE)
        Pos = ind
        Pos[, 1] = ind[, 2]
        Pos[, 2] = -ind[, 1] + 1 + n
        return(Pos)
    }
    testTemp = getPos.Dat(corr)
    Pos = getPos.Dat(corr)[[1]]
    PosName = getPos.Dat(corr)[[3]]
    if (any(is.na(corr)) &amp;&amp; is.character(na.label)) {
        PosNA = getPos.NAs(corr)
    }
    else {
        PosNA = NULL
    }
    AllCoords = rbind(Pos, PosNA)
    n2 = max(AllCoords[, 2])
    n1 = min(AllCoords[, 2])
    nn = n2 - n1
    m2 = max(AllCoords[, 1])
    m1 = min(AllCoords[, 1])
    mm = max(1, m2 - m1)
    expand_expression = function(s) {
        ifelse(grepl("^[:=$]", s), parse(text = substring(s, 
            2)), s)
    }
    newrownames = sapply(rownames(corr)[(n + 1 - n2):(n + 1 - 
        n1)], expand_expression)
    newcolnames = sapply(colnames(corr)[m1:m2], expand_expression)
    DAT = getPos.Dat(corr)[[2]]
    len.DAT = length(DAT)
    rm(expand_expression)
    assign.color = function(dat = DAT, color = col, isSpecialCorr = SpecialCorr) {
        if (isSpecialCorr) {
            newcorr = (dat + 1)/2
        }
        else {
            newcorr = dat
        }
        newcorr[newcorr &lt;= 0] = 0
        newcorr[newcorr &gt;= 1] = 1 - 1e-16
        color[floor(newcorr * length(color)) + 1]
    }
    col.fill = assign.color()
    isFALSE = function(x) identical(x, FALSE)
    isTRUE = function(x) identical(x, TRUE)
    if (isFALSE(tl.pos)) {
        tl.pos = "n"
    }
    if (is.null(tl.pos) || isTRUE(tl.pos)) {
        tl.pos = switch(type, full = "lt", lower = "ld", upper = "td")
    }
    if (isFALSE(cl.pos)) {
        cl.pos = "n"
    }
    if (is.null(cl.pos) || isTRUE(cl.pos)) {
        cl.pos = switch(type, full = "r", lower = "b", upper = "r")
    }
    if (isFALSE(outline)) {
        col.border = col.fill
    }
    else if (isTRUE(outline)) {
        col.border = "black"
    }
    else if (is.character(outline)) {
        col.border = outline
    }
    else {
        stop("Unsupported value type for parameter outline")
    }
    oldpar = par(mar = mar, bg = par()$bg)
    on.exit(par(oldpar), add = TRUE)
    if (!add) {
        plot.new()
        xlabwidth = max(strwidth(newrownames, cex = tl.cex))
        ylabwidth = max(strwidth(newcolnames, cex = tl.cex))
        laboffset = strwidth("W", cex = tl.cex) * tl.offset
        for (i in 1:50) {
            xlim = c(m1 - 0.5 - laboffset - xlabwidth * (grepl("l", 
                tl.pos) | grepl("d", tl.pos)), m2 + 0.5 + mm * 
                cl.ratio * (cl.pos == "r") + xlabwidth * abs(cos(tl.srt * 
                pi/180)) * grepl("d", tl.pos))
            ylim = c(n1 - 0.5 - nn * cl.ratio * (cl.pos == "b") - 
                laboffset, n2 + 0.5 + laboffset + ylabwidth * 
                abs(sin(tl.srt * pi/180)) * grepl("t", tl.pos) + 
                ylabwidth * abs(sin(tl.srt * pi/180)) * (type == 
                  "lower") * grepl("d", tl.pos))
            plot.window(xlim, ylim, asp = 1, xaxs = "i", yaxs = "i")
            x.tmp = max(strwidth(newrownames, cex = tl.cex))
            y.tmp = max(strwidth(newcolnames, cex = tl.cex))
            laboffset.tmp = strwidth("W", cex = tl.cex) * tl.offset
            if (max(x.tmp - xlabwidth, y.tmp - ylabwidth, laboffset.tmp - 
                laboffset) &lt; 0.001) {
                break
            }
            xlabwidth = x.tmp
            ylabwidth = y.tmp
            laboffset = laboffset.tmp
            if (i == 50) {
                warning(c("Not been able to calculate text margin, ", 
                  "please try again with a clean new empty window using ", 
                  "{plot.new(); dev.off()} or reduce tl.cex"))
            }
        }
        if (.Platform$OS.type == "windows") {
            grDevices::windows.options(width = 7, height = 7 * 
                diff(ylim)/diff(xlim))
        }
        xlim = xlim + diff(xlim) * 0.01 * c(-1, 1)
        ylim = ylim + diff(ylim) * 0.01 * c(-1, 1)
        plot.window(xlim = xlim, ylim = ylim, asp = win.asp, 
            xlab = "", ylab = "", xaxs = "i", yaxs = "i")
    }
    laboffset = strwidth("W", cex = tl.cex) * tl.offset
    symbols(Pos, add = TRUE, inches = FALSE, rectangles = matrix(1, 
        len.DAT, 2), bg = bg, fg = bg)
    if (method == "circle" &amp;&amp; plotCI == "n") {
        symbols(Pos, add = TRUE, inches = FALSE, circles = asp_rescale_factor * 
            0.9 * abs(DAT)^0.5/2, fg = col.border, bg = col.fill)
    }
    if (method == "ellipse" &amp;&amp; plotCI == "n") {
        ell.dat = function(rho, length = 99) {
            k = seq(0, 2 * pi, length = length)
            x = cos(k + acos(rho)/2)/2
            y = cos(k - acos(rho)/2)/2
            cbind(rbind(x, y), c(NA, NA))
        }
        ELL.dat = lapply(DAT, ell.dat)
        ELL.dat2 = 0.85 * matrix(unlist(ELL.dat), ncol = 2, byrow = TRUE)
        ELL.dat2 = ELL.dat2 + Pos[rep(1:length(DAT), each = 100), 
            ]
        polygon(ELL.dat2, border = col.border, col = col.fill)
    }
    if (is.null(number.digits)) {
        number.digits = switch(addCoefasPercent + 1, 2, 0)
    }
    stopifnot(number.digits%%1 == 0)
    stopifnot(number.digits &gt;= 0)
    if (method == "number" &amp;&amp; plotCI == "n") {
        x = (DAT - int) * ifelse(addCoefasPercent, 100, 1)/zoom
        text(Pos[, 1], Pos[, 2], font = number.font, col = col.fill, 
            labels = format(round(x, number.digits), nsmall = number.digits), 
            cex = number.cex)
    }
    NA_LABEL_MAX_CHARS = 2
    if (is.matrix(PosNA) &amp;&amp; nrow(PosNA) &gt; 0) {
        stopifnot(is.matrix(PosNA))
        if (na.label == "square") {
            symbols(PosNA, add = TRUE, inches = FALSE, squares = rep(1, 
                nrow(PosNA)), bg = na.label.col, fg = na.label.col)
        }
        else if (nchar(na.label) %in% 1:NA_LABEL_MAX_CHARS) {
            symbols(PosNA, add = TRUE, inches = FALSE, squares = rep(1, 
                nrow(PosNA)), fg = bg, bg = bg)
            text(PosNA[, 1], PosNA[, 2], font = number.font, 
                col = na.label.col, labels = na.label, cex = number.cex, 
                ...)
        }
        else {
            stop(paste("Maximum number of characters for NA label is:", 
                NA_LABEL_MAX_CHARS))
        }
    }
    if (method == "pie" &amp;&amp; plotCI == "n") {
        symbols(Pos, add = TRUE, inches = FALSE, circles = rep(0.5, 
            len.DAT) * 0.85, fg = col.border)
        pie.dat = function(theta, length = 100) {
            k = seq(pi/2, pi/2 - theta, length = 0.5 * length * 
                abs(theta)/pi)
            x = c(0, cos(k)/2, 0)
            y = c(0, sin(k)/2, 0)
            cbind(rbind(x, y), c(NA, NA))
        }
        PIE.dat = lapply(DAT * 2 * pi, pie.dat)
        len.pie = unlist(lapply(PIE.dat, length))/2
        PIE.dat2 = 0.85 * matrix(unlist(PIE.dat), ncol = 2, byrow = TRUE)
        PIE.dat2 = PIE.dat2 + Pos[rep(1:length(DAT), len.pie), 
            ]
        polygon(PIE.dat2, border = "black", col = col.fill)
    }
    if (method == "shade" &amp;&amp; plotCI == "n") {
        symbols(Pos, add = TRUE, inches = FALSE, squares = rep(1, 
            len.DAT), bg = col.fill, fg = addgrid.col)
        shade.dat = function(w) {
            x = w[1]
            y = w[2]
            rho = w[3]
            x1 = x - 0.5
            x2 = x + 0.5
            y1 = y - 0.5
            y2 = y + 0.5
            dat = NA
            if ((addshade == "positive" || addshade == "all") &amp;&amp; 
                rho &gt; 0) {
                dat = cbind(c(x1, x1, x), c(y, y1, y1), c(x, 
                  x2, x2), c(y2, y2, y))
            }
            if ((addshade == "negative" || addshade == "all") &amp;&amp; 
                rho &lt; 0) {
                dat = cbind(c(x1, x1, x), c(y, y2, y2), c(x, 
                  x2, x2), c(y1, y1, y))
            }
            return(t(dat))
        }
        pos_corr = rbind(cbind(Pos, DAT))
        pos_corr2 = split(pos_corr, 1:nrow(pos_corr))
        SHADE.dat = matrix(na.omit(unlist(lapply(pos_corr2, shade.dat))), 
            byrow = TRUE, ncol = 4)
        segments(SHADE.dat[, 1], SHADE.dat[, 2], SHADE.dat[, 
            3], SHADE.dat[, 4], col = shade.col, lwd = shade.lwd)
    }
    if (method == "square" &amp;&amp; plotCI == "n") {
        draw_method_square(Pos, DAT, asp_rescale_factor, col.border, 
            col.fill)
    }
    if (method == "color" &amp;&amp; plotCI == "n") {
        draw_method_color(Pos, col.border, col.fill)
    }
    draw_grid(AllCoords, addgrid.col)
    if (plotCI != "n") {
        if (is.null(lowCI.mat) || is.null(uppCI.mat)) {
            stop("Need lowCI.mat and uppCI.mat!")
        }
        if (order != "original") {
            lowCI.mat = lowCI.mat[ord, ord]
            uppCI.mat = uppCI.mat[ord, ord]
        }
        pos.lowNew = getPos.Dat(lowCI.mat)[[1]]
        lowNew = getPos.Dat(lowCI.mat)[[2]]
        pos.uppNew = getPos.Dat(uppCI.mat)[[1]]
        uppNew = getPos.Dat(uppCI.mat)[[2]]
        k1 = (abs(uppNew) &gt; abs(lowNew))
        bigabs = uppNew
        bigabs[which(!k1)] = lowNew[!k1]
        smallabs = lowNew
        smallabs[which(!k1)] = uppNew[!k1]
        sig = sign(uppNew * lowNew)
        color_bigabs = col[ceiling((bigabs + 1) * length(col)/2)]
        color_smallabs = col[ceiling((smallabs + 1) * length(col)/2)]
        if (plotCI == "circle") {
            symbols(pos.uppNew[, 1], pos.uppNew[, 2], add = TRUE, 
                inches = FALSE, circles = 0.95 * abs(bigabs)^0.5/2, 
                bg = ifelse(sig &gt; 0, col.fill, color_bigabs), 
                fg = ifelse(sig &gt; 0, col.fill, color_bigabs))
            symbols(pos.lowNew[, 1], pos.lowNew[, 2], add = TRUE, 
                inches = FALSE, circles = 0.95 * abs(smallabs)^0.5/2, 
                bg = ifelse(sig &gt; 0, bg, color_smallabs), fg = ifelse(sig &gt; 
                  0, col.fill, color_smallabs))
        }
        if (plotCI == "square") {
            symbols(pos.uppNew[, 1], pos.uppNew[, 2], add = TRUE, 
                inches = FALSE, squares = abs(bigabs)^0.5, bg = ifelse(sig &gt; 
                  0, col.fill, color_bigabs), fg = ifelse(sig &gt; 
                  0, col.fill, color_bigabs))
            symbols(pos.lowNew[, 1], pos.lowNew[, 2], add = TRUE, 
                inches = FALSE, squares = abs(smallabs)^0.5, 
                bg = ifelse(sig &gt; 0, bg, color_smallabs), fg = ifelse(sig &gt; 
                  0, col.fill, color_smallabs))
        }
        if (plotCI == "rect") {
            rect.width = 0.25
            rect(pos.uppNew[, 1] - rect.width, pos.uppNew[, 2] + 
                smallabs/2, pos.uppNew[, 1] + rect.width, pos.uppNew[, 
                2] + bigabs/2, col = col.fill, border = col.fill)
            segments(pos.lowNew[, 1] - rect.width, pos.lowNew[, 
                2] + DAT/2, pos.lowNew[, 1] + rect.width, pos.lowNew[, 
                2] + DAT/2, col = "black", lwd = 1)
            segments(pos.uppNew[, 1] - rect.width, pos.uppNew[, 
                2] + uppNew/2, pos.uppNew[, 1] + rect.width, 
                pos.uppNew[, 2] + uppNew/2, col = "black", lwd = 1)
            segments(pos.lowNew[, 1] - rect.width, pos.lowNew[, 
                2] + lowNew/2, pos.lowNew[, 1] + rect.width, 
                pos.lowNew[, 2] + lowNew/2, col = "black", lwd = 1)
            segments(pos.lowNew[, 1] - 0.5, pos.lowNew[, 2], 
                pos.lowNew[, 1] + 0.5, pos.lowNew[, 2], col = "grey70", 
                lty = 3)
        }
    }
    if (!is.null(addCoef.col) &amp;&amp; method != "number") {
        text(Pos[, 1], Pos[, 2], col = addCoef.col, labels = round((DAT - 
            int) * ifelse(addCoefasPercent, 100, 1)/zoom, number.digits), 
            cex = number.cex, font = number.font)
    }
    if (!is.null(p.mat) &amp;&amp; insig != "n") {
        if (order != "original") {
            p.mat = p.mat[ord, ord]
        }
        if (!is.null(rownames(p.mat)) | !is.null(rownames(p.mat))) {
            if (!all(colnames(p.mat) == colnames(corr)) | !all(rownames(p.mat) == 
                rownames(corr))) {
                warning("p.mat and corr may be not paired, their rownames and colnames are not totally same!")
            }
        }
        pos.pNew = getPos.Dat(p.mat)[[1]]
        pNew = getPos.Dat(p.mat)[[2]]
        if (insig == "label_sig") {
            if (!is.character(pch)) 
                pch = "*"
            place_points = function(sig.locs, point) {
                text(pos.pNew[, 1][sig.locs], pos.pNew[, 2][sig.locs], 
                  labels = point, col = pch.col, cex = pch.cex, 
                  lwd = 2)
            }
            if (length(sig.level) == 1) {
                place_points(sig.locs = which(pNew &lt; sig.level), 
                  point = pch)
            }
            else {
                l = length(sig.level)
                for (i in seq_along(sig.level)) {
                  iter = l + 1 - i
                  pchTmp = paste(rep(pch, i), collapse = "")
                  if (i == length(sig.level)) {
                    locs = which(pNew &lt; sig.level[iter])
                    if (length(locs)) {
                      place_points(sig.locs = locs, point = pchTmp)
                    }
                  }
                  else {
                    locs = which(pNew &lt; sig.level[iter] &amp; pNew &gt; 
                      sig.level[iter - 1])
                    if (length(locs)) {
                      place_points(sig.locs = locs, point = pchTmp)
                    }
                  }
                }
            }
        }
        else {
            ind.p = which(pNew &gt; sig.level)
            p_inSig = length(ind.p) &gt; 0
            if (insig == "pch" &amp;&amp; p_inSig) {
                points(pos.pNew[, 1][ind.p], pos.pNew[, 2][ind.p], 
                  pch = pch, col = pch.col, cex = pch.cex, lwd = 2)
            }
            if (insig == "p-value" &amp;&amp; p_inSig) {
                text(pos.pNew[, 1][ind.p], pos.pNew[, 2][ind.p], 
                  round(pNew[ind.p], number.digits), col = pch.col)
            }
            if (insig == "blank" &amp;&amp; p_inSig) {
                symbols(pos.pNew[, 1][ind.p], pos.pNew[, 2][ind.p], 
                  inches = FALSE, squares = rep(1, length(pos.pNew[, 
                    1][ind.p])), fg = addgrid.col, bg = bg, add = TRUE)
            }
        }
    }
    if (cl.pos != "n") {
        colRange = assign.color(dat = col.lim2)
        ind1 = which(col == colRange[1])
        ind2 = which(col == colRange[2])
        colbar = col[ind1:ind2]
        if (is.null(cl.length)) {
            cl.length = ifelse(length(colbar) &gt; 20, 11, length(colbar) + 
                1)
        }
        labels = seq(col.lim[1], col.lim[2], length = cl.length)
        if (cl.pos == "r") {
            vertical = TRUE
            xlim = c(m2 + 0.5 + mm * 0.02, m2 + 0.5 + mm * cl.ratio)
            ylim = c(n1 - 0.5, n2 + 0.5)
        }
        if (cl.pos == "b") {
            vertical = FALSE
            xlim = c(m1 - 0.5, m2 + 0.5)
            ylim = c(n1 - 0.5 - nn * cl.ratio, n1 - 0.5 - nn * 
                0.02)
        }
        colorlegend(colbar = colbar, labels = round(labels, 2), 
            offset = cl.offset, ratio.colbar = 0.3, cex = cl.cex, 
            xlim = xlim, ylim = ylim, vertical = vertical, align = cl.align.text)
    }
    if (tl.pos != "n") {
        pos.xlabel = cbind(m1:m2, n2 + 0.5 + laboffset)
        pos.ylabel = cbind(m1 - 0.5, n2:n1)
        if (tl.pos == "td") {
            if (type != "upper") {
                stop("type should be 'upper' if tl.pos is 'dt'.")
            }
            pos.ylabel = cbind(m1:(m1 + nn) - 0.5, n2:n1)
        }
        if (tl.pos == "ld") {
            if (type != "lower") {
                stop("type should be 'lower' if tl.pos is 'ld'.")
            }
            pos.xlabel = cbind(m1:m2, n2:(n2 - mm) + 0.5 + laboffset)
        }
        if (tl.pos == "d") {
            pos.ylabel = cbind(m1:(m1 + nn) - 0.5, n2:n1)
            pos.ylabel = pos.ylabel[1:min(n, m), ]
            symbols(pos.ylabel[, 1] + 0.5, pos.ylabel[, 2], add = TRUE, 
                bg = bg, fg = addgrid.col, inches = FALSE, squares = rep(1, 
                  length(pos.ylabel[, 1])))
            text(pos.ylabel[, 1] + 0.5, pos.ylabel[, 2], newcolnames[1:min(n, 
                m)], col = tl.col, cex = tl.cex, ...)
        }
        else {
            if (tl.pos != "l") {
                text(pos.xlabel[, 1], pos.xlabel[, 2], newcolnames, 
                  srt = tl.srt, adj = ifelse(tl.srt == 0, c(0.5, 
                    0), c(0, 0)), col = tl.col, cex = tl.cex, 
                  offset = tl.offset, ...)
            }
            text(pos.ylabel[, 1], pos.ylabel[, 2], newrownames, 
                col = tl.col, cex = tl.cex, pos = 2, offset = tl.offset, 
                ...)
        }
    }
    title(title, ...)
    if (type == "full" &amp;&amp; plotCI == "n" &amp;&amp; !is.null(addgrid.col)) {
        rect(m1 - 0.5, n1 - 0.5, m2 + 0.5, n2 + 0.5, border = addgrid.col)
    }
    if (!is.null(addrect) &amp;&amp; order == "hclust" &amp;&amp; type == "full") {
        corrRect.hclust(corr, k = addrect, method = hclust.method, 
            col = rect.col, lwd = rect.lwd)
    }
    corrPos = data.frame(PosName, Pos, DAT)
    colnames(corrPos) = c("xName", "yName", "x", "y", "corr")
    if (!is.null(p.mat)) {
        corrPos = cbind(corrPos, pNew)
        colnames(corrPos)[6] = c("p.value")
    }
    corrPos = corrPos[order(corrPos[, 3], -corrPos[, 4]), ]
    rownames(corrPos) = NULL
    res = list(corr = corr, corrPos = corrPos, arg = list(type = type))
    invisible(res)
}
&lt;bytecode: 0x7f7cacdfea90&gt;
&lt;environment: namespace:corrplot&gt;</code></pre>
</div>
</div>
</section>
<section id="retrieving-stored-data" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Retrieving Stored Data</h1>
<div class="cell">

</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>price_mlr <span class="ot">&lt;-</span> <span class="fu">lm</span>(resale_price <span class="sc">~</span> floor_area_sqm <span class="sc">+</span> storey_order <span class="sc">+</span> remaining_lease_mths <span class="sc">+</span> PROX_CBD <span class="sc">+</span> WITHIN_350M_CHILDCARE <span class="sc">+</span> PROX_ELDERLYCARE <span class="sc">+</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>               PROX_HAWKER <span class="sc">+</span> WITHIN_350M_KINDERGARTEN <span class="sc">+</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                  PROX_MRT  <span class="sc">+</span> PROX_PARK <span class="sc">+</span> WITHIN_1KM_PRISCH <span class="sc">+</span> PROX_MALL <span class="sc">+</span> PROX_SUPERMARKET <span class="sc">+</span> WITHIN_350M_BUS,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">data=</span>train_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>^note difference between hands on 8/9 and this: mlr is loading the training data instead of whole dataset</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>train_data_sp <span class="ot">&lt;-</span> <span class="fu">as_Spatial</span>(train_data)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>train_data_sp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class       : SpatialPointsDataFrame 
features    : 10335 
extent      : 11597.31, 42623.63, 28217.39, 48741.06  (xmin, xmax, ymin, ymax)
crs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 
variables   : 17
names       : resale_price, floor_area_sqm, storey_order, remaining_lease_mths,          PROX_CBD,     PROX_ELDERLYCARE,        PROX_HAWKER,           PROX_MRT,          PROX_PARK,   PROX_GOOD_PRISCH,        PROX_MALL,            PROX_CHAS,     PROX_SUPERMARKET, WITHIN_350M_KINDERGARTEN, WITHIN_350M_CHILDCARE, ... 
min values  :       218000,             74,            1,                  555, 0.999393538715878, 1.98943787433087e-08, 0.0333358643817954, 0.0220407324774434, 0.0441643212802781, 0.0652540365486641,                0, 6.20621206270077e-09, 1.21715176356525e-07,                        0,                     0, ... 
max values  :      1186888,            133,           17,                 1164,  19.6500691667807,     3.30163731686804,   2.86763031236184,   2.13060636038504,   2.41313695915468,   10.6223726149914, 2.27100643784442,    0.808332738794272,     1.57131703651196,                        7,                    20, ... </code></pre>
</div>
</div>
<p>bw.adaptive methods : same as hands on 8 but only difference is loading the training data</p>
</section>
<section id="preparing-coordinates-data" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Preparing Coordinates Data</h1>
<p>for using package ranger - fast implementation of random forest https://cran.r-project.org/web/packages/ranger/index.html</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>coords <span class="ot">&lt;-</span> <span class="fu">st_coordinates</span>(mdata)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>coords_train <span class="ot">&lt;-</span> <span class="fu">st_coordinates</span>(train_data)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>coords_test <span class="ot">&lt;-</span> <span class="fu">st_coordinates</span>(test_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>coords_train <span class="ot">&lt;-</span> <span class="fu">write_rds</span>(coords_train, <span class="st">"data/model/coords_train.rds"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>coords_test <span class="ot">&lt;-</span> <span class="fu">write_rds</span>(coords_test, <span class="st">"data/model/coords_test.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="dropping-geometry-columns" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Dropping Geometry Columns</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>train_data <span class="ot">&lt;-</span> train_data <span class="sc">%&gt;%</span> <span class="fu">st_drop_geometry</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="calibrating-random-forest" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Calibrating Random Forest</h1>
<p>(using base ranger)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>rf <span class="ot">&lt;-</span> <span class="fu">ranger</span>(resale_price <span class="sc">~</span> floor_area_sqm <span class="sc">+</span> storey_order <span class="sc">+</span> remaining_lease_mths <span class="sc">+</span> PROX_CBD <span class="sc">+</span> WITHIN_350M_CHILDCARE <span class="sc">+</span> PROX_ELDERLYCARE <span class="sc">+</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>               PROX_HAWKER <span class="sc">+</span> WITHIN_350M_KINDERGARTEN <span class="sc">+</span> </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                  PROX_MRT  <span class="sc">+</span> PROX_PARK <span class="sc">+</span> WITHIN_1KM_PRISCH <span class="sc">+</span> PROX_MALL <span class="sc">+</span> PROX_SUPERMARKET <span class="sc">+</span> WITHIN_350M_BUS,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">data=</span>train_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>rf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Ranger result

Call:
 ranger(resale_price ~ floor_area_sqm + storey_order + remaining_lease_mths +      PROX_CBD + WITHIN_350M_CHILDCARE + PROX_ELDERLYCARE + PROX_HAWKER +      WITHIN_350M_KINDERGARTEN + PROX_MRT + PROX_PARK + WITHIN_1KM_PRISCH +      PROX_MALL + PROX_SUPERMARKET + WITHIN_350M_BUS, data = train_data) 

Type:                             Regression 
Number of trees:                  500 
Sample size:                      10335 
Number of independent variables:  14 
Mtry:                             3 
Target node size:                 5 
Variable importance mode:         none 
Splitrule:                        variance 
OOB prediction error (MSE):       726909657 
R squared (OOB):                  0.94969 </code></pre>
</div>
</div>
<p>rf results: - OOB prediction error MSE = mean square error which is a squared value (need to square root before using this value) - lm model residuals are already square rooted - target node size: 5 subsets of original data</p>
</section>
<section id="calibrating-random-forest---adaptive" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Calibrating random forest - adaptive</h1>
<ul>
<li>should not take more than 10min to run</li>
<li>re-running of this code without clearing environment will increase computational time</li>
<li>need to free away unused memory</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>gwRF_adaptive <span class="ot">&lt;-</span> <span class="fu">grf</span>(<span class="at">formula =</span> resale_price <span class="sc">~</span>  floor_area_sqm <span class="sc">+</span> storey_order <span class="sc">+</span> remaining_lease_mths <span class="sc">+</span> PROX_CBD <span class="sc">+</span> WITHIN_350M_CHILDCARE <span class="sc">+</span> PROX_ELDERLYCARE <span class="sc">+</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>               PROX_HAWKER <span class="sc">+</span> WITHIN_350M_KINDERGARTEN <span class="sc">+</span> </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>                  PROX_MRT  <span class="sc">+</span> PROX_PARK <span class="sc">+</span> WITHIN_1KM_PRISCH <span class="sc">+</span> PROX_MALL <span class="sc">+</span> PROX_SUPERMARKET <span class="sc">+</span> WITHIN_350M_BUS,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>               <span class="at">dframe=</span>train_data,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>               <span class="at">bw =</span> <span class="dv">55</span>,</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>               <span class="at">kernel =</span> <span class="st">"adaptive"</span>,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>               <span class="at">coords=</span>coords_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>AIC and AICc should be quite close in value if there is no bias in the data</li>
<li>determining the bandwidth
<ul>
<li>using from geographically weighted method</li>
<li>or using grf.bw (https://cran.r-project.org/web/packages/SpatialML/SpatialML.pdf)</li>
</ul></li>
<li>finding out which models are contributing most, type on console&gt; gwRF_adaptive<span class="math inline">\(Global.Model\)</span>variable.importance</li>
<li>display var importance as a dataframe, type on console or code chunk&gt; vi_df &lt;- as.data.frame(gwRF_adaptive<span class="math inline">\(Global.Model\)</span>variable.importance)</li>
</ul>
</section>
<section id="predicting-using-test-data" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Predicting using Test Data</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>test_data <span class="ot">&lt;-</span> <span class="fu">cbind</span>(test_data, coords_test) <span class="sc">%&gt;%</span> <span class="fu">st_drop_geometry</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>combine back the coordinate data with the test data and drop geometry column from test data</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>gwRF_pred <span class="ot">&lt;-</span> <span class="fu">predict.grf</span>(gwRF_adaptive, </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                         test_data,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">x.var.name=</span><span class="st">"X"</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">y.var.name=</span><span class="st">"Y"</span>,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">local.w=</span> <span class="dv">1</span>,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                         <span class="at">global.w=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>this code will take time to run</li>
<li>local.w = 1 means calibrate the local version</li>
<li>output is a vector</li>
</ul>
<div class="cell">

</div>
<ul>
<li>using ggplot to plot the predict_grf output; see the fit of the model</li>
<li>compare random forest and lm (least square model) output</li>
</ul>
<div class="cell">

</div>
<div class="cell">

</div>
<div class="cell">

</div>
<div class="cell">

</div>
<div class="cell">

</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>